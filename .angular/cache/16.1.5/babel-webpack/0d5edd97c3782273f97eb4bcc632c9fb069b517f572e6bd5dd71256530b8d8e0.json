{"ast":null,"code":"import { GameConstants } from '../constants/game.constants';\nimport { Game } from '../models/game';\nimport { Player } from '../models/player';\nimport { PlayerStats } from '../models/player-stats';\nimport { Round } from '../models/round';\nimport { Team } from '../models/team';\nimport { Throw } from '../models/throw';\nimport { ThrowResult } from '../models/throw-result';\nimport * as i0 from \"@angular/core\";\nexport let GameService = /*#__PURE__*/(() => {\n  class GameService {\n    constructor() {\n      this.teamsKey = 'TEAMS';\n      this.playersKey = 'PLAYERS';\n      this.gamesKey = 'GAMES';\n      this.players = [];\n      this.teams = [];\n      this.games = [];\n      // this.clearData();\n      this.games = JSON.parse(localStorage.getItem(this.gamesKey));\n      this.players = JSON.parse(localStorage.getItem(this.playersKey));\n      this.teams = JSON.parse(localStorage.getItem(this.gamesKey));\n      if (this.players) {\n        this.players.map(x => {\n          if (!x.stats) {\n            x.stats = new PlayerStats();\n          }\n        });\n      }\n    }\n    clearData() {\n      this.players = [];\n      this.teams = [];\n      this.games = [];\n      localStorage.removeItem(this.gamesKey);\n      localStorage.removeItem(this.teamsKey);\n      localStorage.removeItem(this.playersKey);\n    }\n    savePlayers() {\n      localStorage.setItem(this.playersKey, JSON.stringify(this.players));\n    }\n    saveTeams() {\n      localStorage.setItem(this.teamsKey, JSON.stringify(this.teams));\n    }\n    saveGames() {\n      localStorage.setItem(this.gamesKey, JSON.stringify(this.games));\n    }\n    getGames() {\n      return this.games;\n    }\n    loadGame(game) {\n      this.setTeamColor(game.team1);\n      this.setTeamColor(game.team2);\n      game.team1.players.map(x => {\n        if (!x.stats) {\n          x.stats = new PlayerStats();\n        }\n        ;\n      });\n      game.team2.players.map(x => {\n        if (!x.stats) {\n          x.stats = new PlayerStats();\n        }\n        ;\n      });\n    }\n    setTeamColor(team) {\n      const bgColor = team?.teamColor?.backgroundColor ?? (team.teamNumber === 1 ? 'yellow' : 'red');\n      const textColor = team?.teamColor?.textColor ?? (team.teamNumber === 1 ? 'black' : 'white');\n      document.documentElement.style.setProperty(`--team${team.teamNumber}-background-color`, bgColor);\n      document.documentElement.style.setProperty(`--team${team.teamNumber}-color`, textColor);\n      team.players[0].name = team?.teamColor?.name ?? `Team $team.teamNumber}`;\n      this.saveTeams();\n      this.saveGames();\n    }\n    createPlayer(name) {\n      const player = new Player(name);\n      this.players.push(player);\n      this.savePlayers();\n      return player;\n    }\n    createTeam(players, teamNumber, teamColor) {\n      const team = new Team(players, teamNumber, teamColor);\n      this.teams.push(team);\n      this.saveTeams();\n      return team;\n    }\n    createGame(team1, team2) {\n      const game = new Game(team1, team2);\n      this.games.push(game);\n      this.addRound(game);\n      this.saveGames();\n      this.loadGame(game);\n      return game;\n    }\n    updateTeamColor(team) {\n      this.setTeamColor(team);\n    }\n    roundScoreChanged(round) {\n      let team1Score = 0;\n      round.team1Throws.map(x => team1Score += x.points);\n      round.team1TotalScore = team1Score;\n      let team2Score = 0;\n      round.team2Throws.map(x => team2Score += x.points);\n      round.team2TotalScore = team2Score;\n      round.team1NetScore = Math.max(round.team1TotalScore - round.team2TotalScore, 0);\n      round.team2NetScore = Math.max(round.team2TotalScore - round.team1TotalScore, 0);\n      round.complete = !round.team1Throws.find(x => !x.result) && !round.team2Throws.find(x => !x.result);\n      const game = this.games.find(x => x.rounds.includes(round));\n      if (game) {\n        this.calculateGameScore(game);\n      }\n      this.saveGames();\n    }\n    calculateGameScore(game) {\n      let team1Score = 0;\n      game.rounds.map(x => team1Score += x.team1NetScore);\n      game.team1Score = team1Score;\n      let team2Score = 0;\n      game.rounds.map(x => team2Score += x.team2NetScore);\n      game.team2Score = team2Score;\n      if (!game.rounds.find(x => !x.complete)) {\n        game.complete = game.team1Score >= GameConstants.WINNING_SCORE || game.team2Score >= GameConstants.WINNING_SCORE;\n        if (game.complete) {\n          game.winner = game.team1Score >= GameConstants.WINNING_SCORE ? game.team1 : game.team2;\n        } else {\n          game.complete = false;\n          game.winner = null;\n        }\n      }\n    }\n    completeRound(game) {\n      this.calculateStatsForLastRound(game);\n      this.addRound(game);\n    }\n    calculateStatsForLastRound(game) {\n      const lastRound = game.rounds[game.rounds.length - 1];\n      lastRound.team1Throws.map(x => this.updateThrowResult(game.team1.players[0].stats, x.result));\n      lastRound.team2Throws.map(x => this.updateThrowResult(game.team2.players[0].stats, x.result));\n      this.calculateScoringRate(game.team1.players[0].stats);\n      this.calculateScoringRate(game.team2.players[0].stats);\n      this.updateScoreStreak(game);\n    }\n    updateThrowResult(stats, throwResult) {\n      stats.totalThrows++;\n      stats.throwResults[throwResult]++;\n      stats.cornholeRate = stats.throwResults[ThrowResult.Cornhole] / stats.totalThrows;\n    }\n    calculateScoringRate(stats) {\n      const totalPoints = stats.throwResults[ThrowResult.Cornhole] * GameConstants.POINTS[ThrowResult.Cornhole] + stats.throwResults[ThrowResult.OnBoard] * GameConstants.POINTS[ThrowResult.OnBoard];\n      stats.scoringRate = totalPoints / stats.totalThrows * 4;\n    }\n    updateScoreStreak(game) {\n      const lastRound = game.rounds[game.rounds.length - 1];\n      if (lastRound.team1NetScore > 0) {\n        game.team1.scoreStreak += lastRound.team1NetScore;\n        game.team2.scoreStreak = 0;\n      } else if (lastRound.team2NetScore > 0) {\n        game.team2.scoreStreak += lastRound.team2NetScore;\n        game.team1.scoreStreak = 0;\n      }\n    }\n    addRound(game) {\n      const team1Throws = [];\n      const team2Throws = [];\n      for (let i = 0; i < 4; i++) {\n        team1Throws.push(new Throw(null));\n        team2Throws.push(new Throw(null));\n      }\n      game.rounds.push(new Round(team1Throws, team2Throws));\n      this.saveGames();\n    }\n    completeGame(game) {\n      this.calculateStatsForLastRound(game);\n      this.updateScoreStreak(game);\n    }\n    resetStats(game) {\n      game.team1.players.map(x => x.stats = new PlayerStats());\n      game.team2.players.map(x => x.stats = new PlayerStats());\n      this.saveGames();\n    }\n    resetStreak(game) {\n      game.team1.scoreStreak = 0;\n      game.team2.scoreStreak = 0;\n      this.saveGames();\n    }\n    resetGame(game) {\n      this.games.splice(this.games.indexOf(game), 1);\n      const newGame = this.createGame(game.team1, game.team2);\n      this.saveGames();\n      return newGame;\n    }\n  }\n  GameService.ɵfac = function GameService_Factory(t) {\n    return new (t || GameService)();\n  };\n  GameService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GameService,\n    factory: GameService.ɵfac,\n    providedIn: 'root'\n  });\n  return GameService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}